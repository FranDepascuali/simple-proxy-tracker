This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-21T00:05:50.013Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  services/
    auth-service.ts
    metrics-service.ts
    proxy-service.ts
    shutdown-service.ts
  environment.ts
  index.ts
  test.spec.ts
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: src/services/auth-service.ts
================
import { Request, Response } from 'express'

export namespace Auth {
  export function authenticateProxyRequest(
    req: Request,
    res: Response,
  ): boolean {
    const proxyAuth = req.headers['proxy-authorization']
    if (!proxyAuth) {
      res.setHeader(
        'Proxy-Authenticate',
        'Basic realm="Proxy Authentication Required"',
      )
      res.status(407).send('Proxy Authentication Required')
      return false
    }

    try {
      const [username, password] = Buffer.from(
        proxyAuth.split(' ')[1],
        'base64',
      )
        .toString()
        .split(':')

      if (username === 'username' && password === 'password') {
        return true
      }

      res.setHeader(
        'Proxy-Authenticate',
        'Basic realm="Proxy Authentication Required"',
      )
      res.status(407).send('Invalid proxy credentials')
      return false
    } catch (error) {
      res.setHeader(
        'Proxy-Authenticate',
        'Basic realm="Proxy Authentication Required"',
      )
      res.status(407).send('Malformed proxy credentials')
      return false
    }
  }
}

================
File: src/services/metrics-service.ts
================
export interface Metrics {
  bandwidth_usage: string
  top_sites: {
    url: string
    visits: number
  }[]
}

export namespace MetricsService {
  let bandwidthUsage = 0
  const siteVisits = new Map<string, number>()

  export function updateBandwidth(bytes: number): void {
    bandwidthUsage += bytes
  }

  export function siteVisited(hostname: string): void {
    const currentVisits = siteVisits.get(hostname) ?? 0
    siteVisits.set(hostname, currentVisits + 1)
  }

  export function getMetrics(): Metrics {
    const topSites = Array.from(siteVisits.entries())
      .map(([url, visits]) => ({ url, visits }))
      .sort((a, b) => b.visits - a.visits)

    // Convert bytes to human-readable format
    let bandwidthString = ''
    if (bandwidthUsage < 1024) {
      bandwidthString = `${bandwidthUsage}B`
    } else if (bandwidthUsage < 1024 * 1024) {
      bandwidthString = `${(bandwidthUsage / 1024).toFixed(2)}KB`
    } else {
      bandwidthString = `${(bandwidthUsage / (1024 * 1024)).toFixed(2)}MB`
    }

    return {
      bandwidth_usage: bandwidthString,
      top_sites: topSites,
    }
  }

  export function printReport(): void {
    console.log('\nFinal Summary:')
    console.log(JSON.stringify(getMetrics(), null, 2))
  }
}

================
File: src/services/proxy-service.ts
================
import { NextFunction, Request, Response } from 'express'
import { IncomingMessage } from 'http'
import { createProxyMiddleware } from 'http-proxy-middleware'

import { Auth } from './auth-service.js'
import { MetricsService } from './metrics-service.js'

export namespace ProxyService {
  /**
   * Creates the proxy middleware that handles request forwarding and metrics collection
   */
  export function createProxyHandler(
    req: Request,
    res: Response,
    next: NextFunction,
  ) {
    // Skip proxy handling for metrics endpoint
    if (req.path === '/metrics') {
      return next()
    }

    console.log('Incoming request URL:', req.url)

    // Authenticate the proxy request
    if (!Auth.authenticateProxyRequest(req, res)) {
      return // Stop here if authentication failed
    }

    // Create and configure the proxy middleware
    return createProxyMiddleware({
      target: req.url,
      changeOrigin: true,
      on: {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        proxyRes: (proxyRes: IncomingMessage, req: Request, res: Response) => {
          console.log('Proxy response:', proxyRes.statusCode)

          // Track response data for bandwidth metrics
          proxyRes.on('data', (chunk: Buffer) => {
            console.log('Response data:', chunk.length)
            MetricsService.updateBandwidth(chunk.length)
          })
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        proxyReq: (proxyReq, req: Request, res: Response) => {
          console.log('Proxy request:', req.url)

          // Track site visits and request bandwidth
          MetricsService.siteVisited(req.url)

          req.on('data', (chunk: Buffer) => {
            console.log('Request data:', chunk.length)
            MetricsService.updateBandwidth(chunk.length)
          })
        },
        error: (err: Error, req: Request, res: Response) => {
          console.error('Proxy error:', err)
          res.status(500).setHeader('Content-Type', 'text/plain')
          res.end('Proxy error occurred')
        },
      },
    })(req, res, next)
  }
}

================
File: src/services/shutdown-service.ts
================
export namespace ShutdownService {
  /**
   * Registers all shutdown handlers for the application.
   * This should be called once when the application starts.
   */
  export function onShutdown(callback: () => void): void {
    process.on('SIGTERM', callback)
    process.on('SIGINT', callback)
  }
}

================
File: src/environment.ts
================
export namespace Environment {

  export const PORT = process.env.PORT ?? 3000
  

}

================
File: src/index.ts
================
import { Environment } from '@src/environment.js'
import { MetricsService } from '@src/services/metrics-service.js'
import { ProxyService } from '@src/services/proxy-service.js'
import { ShutdownService } from '@src/services/shutdown-service.js'
import express, { NextFunction, Request, Response } from 'express'

const app = express()

app.get('/metrics', (request: Request, response: Response) => {
  response.json(MetricsService.getMetrics())
})

app.use((req: Request, res: Response, next: NextFunction) => {
  if (req.path === '/metrics') {
    return next()
  }

  return ProxyService.createProxyHandler(req, res, next)
})

ShutdownService.onShutdown(() => {
  console.log('\nShutting down proxy server...')
  MetricsService.printReport()
})

app.listen(Environment.PORT, () => {
  console.log(`Proxy server running on port ${Environment.PORT}`)
})

================
File: src/test.spec.ts
================
import { expect, test } from 'vitest'

test('adds 1 + 2 to equal 3', () => {
  expect(1 + 2).toBe(3)
})

================
File: package.json
================
{
  "name": "sample-project",
  "version": "1.0.0",
  "description": "",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx --config .eslintrc.cjs",
    "build": "npm run lint && tsc --outDir dist",
    "dev": "tsx src/index.ts --outDir dist --watch",
    "test": "npm run build; vitest --run"
  },
  "dependencies": {
    "express": "^4.21.2",
    "express-basic-auth": "^1.2.1",
    "http-proxy-middleware": "^3.0.3"
  },
  "devDependencies": {
    "@trivago/prettier-plugin-sort-imports": "4.3.0",
    "@types/dotenv": "^6.1.1",
    "@types/express": "^5.0.0",
    "@typescript-eslint/eslint-plugin": "6.19.0",
    "@typescript-eslint/parser": "6.19.0",
    "eslint": "8.56.0",
    "eslint-config-prettier": "9.1.0",
    "prettier": "3.2.4",
    "tsx": "4.7.0",
    "typescript": "5.3.3",
    "vite-tsconfig-paths": "^4.3.2",
    "vitest": "1.2.1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module"
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "moduleResolution": "NodeNext",
    "module": "NodeNext",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictBindCallApply": true,
    "noFallthroughCasesInSwitch": false,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "paths": {
      "@src/*": [
        "src/*"
      ]
    },
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "vite.config.ts",
    "./build.ts",
    "node_modules",
    "**/dist"
  ]
}
